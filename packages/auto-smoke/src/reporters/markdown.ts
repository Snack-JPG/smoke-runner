import * as fs from 'fs';
import * as path from 'path';

export interface TestResult {
  route: string;
  status: 'passed' | 'failed' | 'skipped';
  errors?: string[];
  axeViolations?: any[];
  duration?: number;
  screenshot?: string;
}

export interface LighthouseResult {
  performance?: number;
  accessibility?: number;
  bestPractices?: number;
  seo?: number;
  pwa?: number;
}

export interface ReportData {
  testResults: TestResult[];
  lighthouseResults?: LighthouseResult;
  totalRoutes: number;
  passed: number;
  failed: number;
  skipped: number;
  duration: number;
  timestamp: string;
}

export class MarkdownReporter {
  private outputPath: string;

  constructor(outputPath: string = './smoke-report.md') {
    this.outputPath = outputPath;
  }

  generateReport(data: ReportData): string {
    const { testResults, lighthouseResults, totalRoutes, passed, failed, skipped, duration } = data;
    
    let markdown = `# 🔥 Smoke Test Report\n\n`;
    markdown += `**Generated:** ${new Date().toLocaleString()}\n`;
    markdown += `**Duration:** ${(duration / 1000).toFixed(2)}s\n\n`;
    
    markdown += `## Summary\n\n`;
    markdown += `| Metric | Count |\n`;
    markdown += `|--------|-------|\n`;
    markdown += `| Total Routes | ${totalRoutes} |\n`;
    markdown += `| ✅ Passed | ${passed} |\n`;
    markdown += `| ❌ Failed | ${failed} |\n`;
    markdown += `| ⏭️ Skipped | ${skipped} |\n\n`;
    
    if (failed > 0) {
      markdown += `## Failed Routes\n\n`;
      const failedTests = testResults.filter(r => r.status === 'failed').slice(0, 10);
      
      for (const test of failedTests) {
        markdown += `### 🔴 ${test.route}\n\n`;
        
        if (test.errors && test.errors.length > 0) {
          markdown += `**Errors:**\n`;
          test.errors.slice(0, 3).forEach(error => {
            markdown += `- ${this.escapeMarkdown(error)}\n`;
          });
          markdown += '\n';
        }
        
        if (test.axeViolations && test.axeViolations.length > 0) {
          markdown += `**Accessibility Violations:**\n`;
          test.axeViolations.slice(0, 3).forEach(violation => {
            markdown += `- **${violation.id}**: ${violation.description} (${violation.impact})\n`;
          });
          markdown += '\n';
        }
        
        if (test.screenshot) {
          markdown += `**Screenshot:** [View](${test.screenshot})\n\n`;
        }
      }
    }
    
    if (lighthouseResults) {
      markdown += `## Lighthouse Scores\n\n`;
      markdown += `| Category | Score |\n`;
      markdown += `|----------|-------|\n`;
      
      if (lighthouseResults.performance !== undefined) {
        markdown += `| Performance | ${this.getScoreEmoji(lighthouseResults.performance)} ${Math.round(lighthouseResults.performance * 100)} |\n`;
      }
      if (lighthouseResults.accessibility !== undefined) {
        markdown += `| Accessibility | ${this.getScoreEmoji(lighthouseResults.accessibility)} ${Math.round(lighthouseResults.accessibility * 100)} |\n`;
      }
      if (lighthouseResults.bestPractices !== undefined) {
        markdown += `| Best Practices | ${this.getScoreEmoji(lighthouseResults.bestPractices)} ${Math.round(lighthouseResults.bestPractices * 100)} |\n`;
      }
      if (lighthouseResults.seo !== undefined) {
        markdown += `| SEO | ${this.getScoreEmoji(lighthouseResults.seo)} ${Math.round(lighthouseResults.seo * 100)} |\n`;
      }
      markdown += '\n';
    }
    
    const topAxeViolations = this.getTopAxeViolations(testResults);
    if (topAxeViolations.length > 0) {
      markdown += `## Top Accessibility Issues\n\n`;
      topAxeViolations.slice(0, 3).forEach((violation, index) => {
        markdown += `${index + 1}. **${violation.id}** (${violation.count} occurrences)\n`;
        markdown += `   ${violation.description}\n\n`;
      });
    }
    
    markdown += `## Artifacts\n\n`;
    markdown += `- [Playwright HTML Report](./playwright-report/index.html)\n`;
    markdown += `- [Screenshots](./packages/auto-smoke/__screenshots__/)\n`;
    markdown += `- [Test Results](./test-results/)\n\n`;
    
    markdown += `---\n`;
    markdown += `*Generated by @smoke-runner/auto-smoke*\n`;
    
    return markdown;
  }

  private getScoreEmoji(score: number): string {
    if (score >= 0.9) return '🟢';
    if (score >= 0.5) return '🟡';
    return '🔴';
  }

  private escapeMarkdown(text: string): string {
    return text.replace(/[*_`[\]()#+-!]/g, '\\$&');
  }

  private getTopAxeViolations(testResults: TestResult[]): any[] {
    const violationCounts = new Map<string, any>();
    
    for (const result of testResults) {
      if (result.axeViolations) {
        for (const violation of result.axeViolations) {
          if (!violationCounts.has(violation.id)) {
            violationCounts.set(violation.id, {
              id: violation.id,
              description: violation.description,
              count: 0
            });
          }
          violationCounts.get(violation.id)!.count++;
        }
      }
    }
    
    return Array.from(violationCounts.values())
      .sort((a, b) => b.count - a.count);
  }

  async saveReport(data: ReportData): Promise<void> {
    const markdown = this.generateReport(data);
    const dir = path.dirname(this.outputPath);
    
    if (!fs.existsSync(dir)) {
      fs.mkdirSync(dir, { recursive: true });
    }
    
    fs.writeFileSync(this.outputPath, markdown);
    console.log(`📄 Report saved to ${this.outputPath}`);
  }

  async sendToSlack(webhookUrl: string, data: ReportData): Promise<void> {
    const summary = {
      text: `Smoke Test Results: ${data.passed}/${data.totalRoutes} passed`,
      blocks: [
        {
          type: 'header',
          text: {
            type: 'plain_text',
            text: '🔥 Smoke Test Results'
          }
        },
        {
          type: 'section',
          fields: [
            {
              type: 'mrkdwn',
              text: `*Total Routes:* ${data.totalRoutes}`
            },
            {
              type: 'mrkdwn',
              text: `*Duration:* ${(data.duration / 1000).toFixed(2)}s`
            },
            {
              type: 'mrkdwn',
              text: `*Passed:* ✅ ${data.passed}`
            },
            {
              type: 'mrkdwn',
              text: `*Failed:* ❌ ${data.failed}`
            }
          ]
        }
      ]
    };
    
    if (data.failed > 0) {
      const failedRoutes = data.testResults
        .filter(r => r.status === 'failed')
        .slice(0, 5)
        .map(r => r.route)
        .join('\n• ');
      
      summary.blocks.push({
        type: 'section',
        text: {
          type: 'mrkdwn',
          text: `*Failed Routes:*\n• ${failedRoutes}`
        }
      });
    }
    
    try {
      const response = await fetch(webhookUrl, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json'
        },
        body: JSON.stringify(summary)
      });
      
      if (!response.ok) {
        console.error('Failed to send Slack notification:', response.statusText);
      }
    } catch (error) {
      console.error('Error sending Slack notification:', error);
    }
  }
}